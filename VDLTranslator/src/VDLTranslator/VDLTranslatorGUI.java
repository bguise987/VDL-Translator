/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//Created by Ben Guise
//for Human Engineering Research Laboratories
//spring 2014

package VDLTranslator;

import javax.swing.JFileChooser;
import javax.swing.filechooser.FileNameExtensionFilter;
import java.io.*;
import java.util.ArrayList;
import javax.swing.JOptionPane;
//import java.util.concurrent.TimeUnit; //Used if we need to have a Java time object

/**
 *
 * @author Ben
 */
public class VDLTranslatorGUI extends javax.swing.JFrame {
    File sourceFile,outFile;
    String fileName;
    PrintWriter outputFile;
    /**
     * Creates new form VDLTranslatorGUI
     */
    public VDLTranslatorGUI() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        fileChooser = new javax.swing.JFileChooser();
        convertButton = new javax.swing.JButton();
        filenameTextField = new javax.swing.JTextField();
        selectButton = new javax.swing.JButton();
        statusLabel = new javax.swing.JLabel();
        jMenuBar1 = new javax.swing.JMenuBar();
        jMenu1 = new javax.swing.JMenu();
        fileMenuQuit = new javax.swing.JMenuItem();
        jMenu2 = new javax.swing.JMenu();
        aboutDialogOpen = new javax.swing.JMenuItem();

        fileChooser.setDialogTitle("VDL File to Convert");

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("VDL Translator");

        convertButton.setText("Convert");
        convertButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                convertButtonActionPerformed(evt);
            }
        });

        filenameTextField.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                filenameTextFieldActionPerformed(evt);
            }
        });

        selectButton.setText("Select File");
        selectButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                selectButtonActionPerformed(evt);
            }
        });

        statusLabel.setText("Ready");

        jMenu1.setText("File");

        fileMenuQuit.setText("Quit");
        fileMenuQuit.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                fileMenuQuitActionPerformed(evt);
            }
        });
        jMenu1.add(fileMenuQuit);

        jMenuBar1.add(jMenu1);

        jMenu2.setText("About");

        aboutDialogOpen.setText("About this Program");
        aboutDialogOpen.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                aboutDialogOpenActionPerformed(evt);
            }
        });
        jMenu2.add(aboutDialogOpen);

        jMenuBar1.add(jMenu2);

        setJMenuBar(jMenuBar1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(56, 56, 56)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(statusLabel)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                        .addComponent(filenameTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 188, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGroup(layout.createSequentialGroup()
                            .addComponent(selectButton)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(convertButton))))
                .addContainerGap(383, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(100, Short.MAX_VALUE)
                .addComponent(filenameTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(convertButton)
                    .addComponent(selectButton))
                .addGap(18, 18, 18)
                .addComponent(statusLabel)
                .addGap(37, 37, 37))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void convertButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_convertButtonActionPerformed
        // TODO add your handling code here:
        statusLabel.setText("Now converting " + sourceFile.getName());
        String outFileName = sourceFile.getName();

        outFileName = outFileName.substring(0,outFileName.length() - 4);
        outFileName = outFileName + ".csv";
        String fileDir = sourceFile.getParent();
        outFile = new File(fileDir,outFileName);
        try {
            outputFile = new PrintWriter(outFile);
        }
        catch (FileNotFoundException e) {
            statusLabel.setText("ERROR:  Could not create output file!");
        }
        try {
            vdlDataAssemble(sourceFile, outputFile);
        }
        catch (IOException e) {
            statusLabel.setText("ERROR:  File not found!");
        }
        catch (InterruptedException e) {
            statusLabel.setText("ERROR: Check handling of writing to file from multiple threads");
        }
    }//GEN-LAST:event_convertButtonActionPerformed

    private void filenameTextFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_filenameTextFieldActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_filenameTextFieldActionPerformed

    private void selectButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_selectButtonActionPerformed
        // TODO add your handling code here:
        FileNameExtensionFilter datFilter = new FileNameExtensionFilter("DAT files (*.DAT)", "DAT");
        fileChooser.setFileFilter(datFilter);
        int fileChooseRetVal = fileChooser.showOpenDialog(VDLTranslatorGUI.this);
        if (fileChooseRetVal == JFileChooser.APPROVE_OPTION) {
            sourceFile = fileChooser.getSelectedFile();
            filenameTextField.setText(sourceFile.getName());
        }
        if (!filenameTextField.getText().equals("")) {
                statusLabel.setText("File selected");
        }
    }//GEN-LAST:event_selectButtonActionPerformed

    private void fileMenuQuitActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_fileMenuQuitActionPerformed
        System.exit(0);
    }//GEN-LAST:event_fileMenuQuitActionPerformed

    private void aboutDialogOpenActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_aboutDialogOpenActionPerformed
        JOptionPane.showMessageDialog(null, "Created by Ben Guise \nfor Human Engineering Research Laboratories\nSpring 2014");
    }//GEN-LAST:event_aboutDialogOpenActionPerformed

    private void vdlDataAssemble (File fileToConvert, PrintWriter outputFile) throws IOException, InterruptedException {
      
        FileInputStream inputFile = new FileInputStream(fileToConvert);
        inputFile.skip(1104);   // Skip the file header

        int tempBufferSize = 16;    //Memory map is in 16 byte chunks
        int beginStampCnt = 0, endStampCnt = 0; //Keep track of begin & end stamps we encounter
        boolean translateData = false;  //Only translate & save data occuring after beginStamps
        int[] beginStamp = new int[7];
        int[] endStamp = new int[7];
        ArrayList<int[]> tempDataStorage = new ArrayList<>(4000);    //Used to store data set before it is made into an object
        LinkedList dataSetList = new LinkedList();  //Used to store PathlockData objects
        statusLabel.setText("Please wait: Conversion in progress");
        //***more efficient way to read in the data rather than byte by byte
        byte[]  bigBuffer = new byte[290304000];    //This number chosen as it should be large enough to handle data produced if
        // VDL were run for 3 weeks continuously collecting data
        byte[] byteBuffer = new byte[8192];
        int position = 0;
        int count = inputFile.read(byteBuffer);
        final int hex_A = 10;
        final int hex_B = 11;
        final int hex_E = 14;
        
        while (count >= 0) {
            System.arraycopy(byteBuffer, 0, bigBuffer, position, count);
            position += count;
            byteBuffer = new byte[8192];
            count = inputFile.read(byteBuffer);
        }
        

        //for loop for reading the data from memory
        for (int k = 0; k < position; k += tempBufferSize) {
            int[] tempByteArray = new int[tempBufferSize];
            for (int i = 0; i < tempByteArray.length; i++) {
                int x = bigBuffer[k + i] & 0xff;    // AND with 0xff to convert to int
                tempByteArray[i] = x;
            }
            
            if (translateData && (tempByteArray[15] == hex_A)) {  //Add this data to storage
                tempDataStorage.add(tempByteArray);
            }
            else if ((tempByteArray[15] == hex_E) && translateData) { //Translate an end stamp
                endStamp = timeStampConvert(tempByteArray); 
                endStampCnt++;
                //Here's where we'll make a new dataset object and start the processing on it
                PathlockData dataSet = new PathlockData(beginStamp, endStamp, tempDataStorage);
                dataSet.run();
                dataSetList.add(dataSet);
                tempDataStorage.clear();
                translateData = false;
            }
            else if (tempByteArray[15] == hex_B) { //Translate a beginning stamp
                if (translateData) {
                    System.out.println("Encountered a begin stamp when we shouldn't have at " + beginStampCnt);
                }
                beginStamp = timeStampConvert(tempByteArray);
                beginStampCnt++;
                translateData = true;
            }
        }
        inputFile.close();
        
        
        // ADDED TO DEBUG FOR ERIC
        System.out.println("Closed the input file");
        
        
        
        //Iterate through LinkedList, if object is done, write to file:
        //Also add up total time
        double fileTotalTime = 0;
        for (int i = 0; i < endStampCnt; i++) {
            PathlockData temp = dataSetList.get(i);
            while (!temp.getConversionStatus()) {

            }
            temp.dataDump(outputFile);
            fileTotalTime += temp.getTotalTime();
        }
        outputFile.close();
        
        
        statusLabel.setText("Conversion complete! Saw " + beginStampCnt + " BeginStamps " + endStampCnt + " EndStamps \nTotal time: " + fileTotalTime + "seconds");
    }

    
    public int[] timeStampConvert(int[] byteArray) {
        int year = byteArray[11];
        int ten_year = year >> 4;
        int one_year = year & 15;
        year = (ten_year * 10) + one_year;
        year += 2000;

        int month = byteArray[10];
        int ten_month = month >> 4;
        int one_month = month & 15;
        month = (ten_month * 10) + one_month;

        int day = byteArray[9];
        int ten_day = day >> 4;
        int one_day = day & 15;
        day = (ten_day * 10) + one_day;

        int hour = byteArray[7];
        int ten_hour = hour >> 4;
        int one_hour = hour & 15;
        hour = (ten_hour * 10) + one_hour;

        int minute = byteArray[6];
        int ten_minute = minute >> 4;
        int one_minute = minute & 15;
        minute = (ten_minute * 10) + one_minute;

        int second = byteArray[5];
        int ten_second = second >> 4;
        int one_second = second & 15;
        second = (ten_second * 10) + one_second;

        int centisec = byteArray[4];
        int ten_centisec = centisec >> 4;
        int one_centisec = centisec & 15;
        centisec = (ten_centisec * 10) + one_centisec;
        int [] timeStamp = {centisec, second, minute, hour, day, month, year};
        return timeStamp;
    }

    
    
    
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(VDLTranslatorGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(VDLTranslatorGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(VDLTranslatorGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(VDLTranslatorGUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new VDLTranslatorGUI().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenuItem aboutDialogOpen;
    private javax.swing.JButton convertButton;
    private javax.swing.JFileChooser fileChooser;
    private javax.swing.JMenuItem fileMenuQuit;
    private javax.swing.JTextField filenameTextField;
    private javax.swing.JMenu jMenu1;
    private javax.swing.JMenu jMenu2;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JButton selectButton;
    private javax.swing.JLabel statusLabel;
    // End of variables declaration//GEN-END:variables








    // LinkedList class created by Ben Guise for COE 0445 at Pitt
    private class LinkedList {

            private Node head;
            private Node tail;
            private int size;

            public LinkedList() {
            }

            public void add(PathlockData value) {
                    Node n = new Node(null, value);
                    if (tail == null) {
                            head = tail = n;
                    } else {
                            tail.setNext(n);
                    }
                    tail = n;
                    size++;
            }

            public void clear() {
                    head = tail = null;
                    size = 0;
            }

            public boolean isEmpty() {
                    return size() == 0;
            }

            public int size() {
                    return size;
            }

            private Node getNodeBefore(int position) {
                    Node result = null;
                    if (position > 0) {
                            int count = 0;
                            Node current = head;
                            while (count < (position - 1) && current != null) {
                                    current = current.getNext();
                                    count++;
                            }
                            result = current;
                    }
                    return result;
            }

            public PathlockData get(int index) {
                    PathlockData result = null;
                    if (index == 0 && head != null) {
                            result = head.getValue();
                    } else {
                            Node previous = getNodeBefore(index);
                            if (previous != null && previous.getNext() != null) {
                                    result = previous.getNext().getValue();
                            }
                    }
                    return result;
            }

            public PathlockData remove(int index) {
                    PathlockData result = null;
                    if (index == 0) {
                            if (head != null) {	
                                    result = head.getValue();
                                    head = head.getNext();
                                    size--;
                            }
                            if (size == 0) {
                                    tail = null;
                            }
                    } else {
                            Node previous = getNodeBefore(index);
                            result = removeNext(previous);
                    }
                    return result;
            }

            private PathlockData removeNext(Node previous) {
                    PathlockData result = null;
                    if (previous != null && previous.getNext() != null) {
                            Node toRemove = previous.getNext();
                            result = toRemove.getValue();
                            previous.setNext(previous.getNext().getNext());
                            if (tail == toRemove) {
                                    tail = previous;
                            }
                            size--;
                    }
                    return result;
            }

            public boolean remove(PathlockData value) {
                    int currentSize = size;
                    if (head != null) {
                            if (head.getValue().equals(value)) {
                                    head = head.getNext();
                                    size--;
                                    if (size == 0) {
                                            tail = null;
                                    }
                            } else {
                                    Node current = head;
                                    while (current.getNext() != null) {
                                            if (current.getNext().getValue().equals(value)) {
                                                    removeNext(current);
                                            }
                                            current = current.getNext();
                                    }
                            }
                    }	
                    return (currentSize < size);
            }

            public void print() {
                    Node current = head;
                    System.out.print("head => ");
                    while (current != null) {
                            System.out.print(current.getValue());
                            current = current.getNext();
                            System.out.print(" => ");
                    }
                    System.out.println();
            }

            private class Node {
                    private PathlockData value;
                    private Node next;

                    public Node(Node next, PathlockData value) {
                            this.next = next;
                            this.value = value;
                    }

                    public Node getNext() {
                            return next;
                    }

                    public void setNext(Node next) {
                            this.next = next;
                    }

                    public PathlockData getValue() {
                            return value;
                    }
            }
    }
}